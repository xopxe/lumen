<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Reference</title>
    <link rel="stylesheet" href="../ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>Lumen</h1>

<ul>
  <li><a href="../index.html">Index</a></li>
</ul>

<h2>Contents</h2>
<ul>
<li><a href="#Functions">Functions</a></li>
<li><a href="#Tables">Tables</a></li>
<li><a href="#Fields">Fields</a></li>
<li><a href="#Data_structures">Data structures </a></li>
</ul>


<h2>Modules</h2>
<ul>
  <li><a href="../modules/catalog.html">catalog</a></li>
  <li><a href="../modules/log.html">log</a></li>
  <li><a href="../modules/mutex.html">mutex</a></li>
  <li><a href="../modules/pipes.html">pipes</a></li>
  <li><a href="../modules/proxy.html">proxy</a></li>
  <li><strong>sched</strong></li>
  <li><a href="../modules/selector.html">selector</a></li>
  <li><a href="../modules/shell.html">shell</a></li>
  <li><a href="../modules/stream.html">stream</a></li>
</ul>
<h2>Topics</h2>
<ul>
  <li><a href="../topics/README.md.html">README.md</a></li>
</ul>
<h2>Examples</h2>
<ul>
  <li><a href="../examples/test-mutex.lua.html">test-mutex.lua</a></li>
  <li><a href="../examples/test-pause.lua.html">test-pause.lua</a></li>
  <li><a href="../examples/test-pipe.lua.html">test-pipe.lua</a></li>
  <li><a href="../examples/test-selector.lua.html">test-selector.lua</a></li>
  <li><a href="../examples/test-stress.lua.html">test-stress.lua</a></li>
  <li><a href="../examples/test.lua.html">test.lua</a></li>
</ul>

</div>

<div id="content">

<h1>Module <code>sched</code></h1>

<p>Lumen cooperative scheduler.</p>
<p> Lumen (Lua Multitasking Environment) is a simple environment
 for coroutine based multitasking. Consists of a signal scheduler,
 and that's it.</p>
    <h3>Usage:</h3>
    <ul>
        <pre class="example"> local sched = require &apos;lumen.sched&apos;
 sched.sigrun({&apos;a signal&apos;}, print)
 local task=sched.run(function()
   sched.signal(&apos;a signal&apos;, &apos;data&apos;)
   sched.sleep(1)
 end)</pre>
    </ul>


<h2><a href="#Functions">Functions</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#get_time">get_time&nbsp;()</a></td>
	<td class="summary">Function used by the scheduler to get current time.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#new_waitd">new_waitd&nbsp;(waitd_table)</a></td>
	<td class="summary">Create a Wait Descriptor.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wait">wait&nbsp;(waitd)</a></td>
	<td class="summary">Wait for a signal.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#sleep">sleep&nbsp;(timeout)</a></td>
	<td class="summary">Sleeps the task for t time units.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#new_task">new_task&nbsp;(f)</a></td>
	<td class="summary">Create a task.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#attach">attach&nbsp;(taskd, taskd_child)</a></td>
	<td class="summary">Attach a task to another.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#set_as_attached">set_as_attached&nbsp;(taskd)</a></td>
	<td class="summary">Set a task as attached to the creator task.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#run">run&nbsp;(task, ...)</a></td>
	<td class="summary">Run a task.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#sigrun">sigrun&nbsp;(waitd, f, attached)</a></td>
	<td class="summary">Create and run a task that listens for a signal.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#sigrunonce">sigrunonce&nbsp;(waitd, f, attached)</a></td>
	<td class="summary">Create and run a task that listens for a signal, once.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#set_pause">set_pause&nbsp;(taskd, pause)</a></td>
	<td class="summary">Pause a task.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#kill">kill&nbsp;(taskd)</a></td>
	<td class="summary">Finishes a task.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#signal">signal&nbsp;(event, ...)</a></td>
	<td class="summary">Emit a signal.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#schedule_signal">schedule_signal&nbsp;(event, ...)</a></td>
	<td class="summary">Emit a signal lazily.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#step">step&nbsp;()</a></td>
	<td class="summary">Runs a single step of the scheduler.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#loop">loop&nbsp;()</a></td>
	<td class="summary">Wait for the scheduler to finish.</td>
	</tr>
</table>
<h2><a href="#Tables">Tables</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#EVENT_ANY">EVENT_ANY</a></td>
	<td class="summary">Event used for all events
 When included in a <a href="../modules/sched.html#waitd">waitd</a>, will match any event.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#tasks">tasks</a></td>
	<td class="summary">Tasks in scheduler.</td>
	</tr>
</table>
<h2><a href="#Fields">Fields</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#running_task">running_task</a></td>
	<td class="summary">Currently running task.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#EVENT_DIE">EVENT_DIE</a></td>
	<td class="summary">Task died event.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#EVENT_FINISH">EVENT_FINISH</a></td>
	<td class="summary">Task finished event.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#to_clean_up">to_clean_up</a></td>
	<td class="summary">Control memory collection.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#idle">idle</a></td>
	<td class="summary">Idle function.</td>
	</tr>
</table>
<h2><a href="#Data_structures">Data structures </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#waitd">waitd</a></td>
	<td class="summary">Wait descriptor.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#taskd">taskd</a></td>
	<td class="summary">Task descriptor.</td>
	</tr>
</table>

<br/>
<br/>


    <h2><a name="Functions"></a>Functions</h2>
    <dl class="function">
    <dt>
    <a name = "get_time"></a>
    <strong>get_time&nbsp;()</strong>
    </dt>
    <dd>
    Function used by the scheduler to get current time.
 Replace with whatever your app uses. LuaSocket's gettime works just fine.
 Defaults to os.time.






</dd>
    <dt>
    <a name = "new_waitd"></a>
    <strong>new_waitd&nbsp;(waitd_table)</strong>
    </dt>
    <dd>
    Create a Wait Descriptor.
 Creates <a href="../modules/sched.html#waitd">waitd</a> object in the scheduler. Notice that buffering waitds
 start buffering as soon they are created.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">waitd_table</span>
         a table to convert into a wait descriptor.</li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        a wait descriptor object.
    </ol>




</dd>
    <dt>
    <a name = "wait"></a>
    <strong>wait&nbsp;(waitd)</strong>
    </dt>
    <dd>
    Wait for a signal.
 Pauses the task until (one of) the specified signal(s) is available.
 If there is a signal in the buffer, will return it immediately.
 Otherwise will block the task until signal arrival, or a timeout.
 If provided a table as parameter, will use <a href="../modules/sched.html#new_waitd">new_waitd</a> to convert it
 to a wait desciptor. If param is <em>nil</em> will yield to other tasks (as
 in cooperative multitasking)
 Can be invoked as waitd:wait().

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">waitd</span>
         a Wait Descriptor for the signal (see <a href="../modules/sched.html#waitd">waitd</a>)</li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        On event returns <em>event, parameters</em>. On timeout
 returns <em>nil, 'timeout'</em>
    </ol>




</dd>
    <dt>
    <a name = "sleep"></a>
    <strong>sleep&nbsp;(timeout)</strong>
    </dt>
    <dd>
    Sleeps the task for t time units.
 Time computed according to @{get_time}.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">timeout</span>
         time to sleep</li>
    </ul>





</dd>
    <dt>
    <a name = "new_task"></a>
    <strong>new_task&nbsp;(f)</strong>
    </dt>
    <dd>
    Create a task.
 The task is created in paused mode. To run the created task,
 use <a href="../modules/sched.html#run">run</a> or <a href="../modules/sched.html#set_pause">set_pause</a>.
 The task will emit a <em>sched.EVENT_FINISH, true, params...</em>
 signal upon normal finalization, were params are the returns of f.
 If there is a error, the task will emit a <em>sched.EVENT_DIE, false, err</em> were
 err is the error message.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">f</span>
         function for the task</li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        task in the scheduler (see <a href="../modules/sched.html#taskd">taskd</a>).
    </ol>




</dd>
    <dt>
    <a name = "attach"></a>
    <strong>attach&nbsp;(taskd, taskd_child)</strong>
    </dt>
    <dd>
    Attach a task to another.
 An attached task will be killed by the scheduler whenever
 the parent task is finished (returns, errors or is killed). Can be
 invoked as taskd:attach(taskd_child).

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">taskd</span>
         The parent task</li>
        <li><span class="parameter">taskd_child</span>
         The child (attached) task.</li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        the modified taskd.
    </ol>




</dd>
    <dt>
    <a name = "set_as_attached"></a>
    <strong>set_as_attached&nbsp;(taskd)</strong>
    </dt>
    <dd>
    Set a task as attached to the creator task.
 An attached task will be killed by the scheduler whenever
 the parent task (the task that created it) is finished (returns, errors or is killed).
 Can be invoked as taskd:set_as_attached().

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">taskd</span>
         The child (attached) task.</li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        the modified taskd.
    </ol>




</dd>
    <dt>
    <a name = "run"></a>
    <strong>run&nbsp;(task, ...)</strong>
    </dt>
    <dd>
    Run a task.
 Can be provided either a <a href="../modules/sched.html#taskd">taskd</a> or a function, with optional parameters.
 If provided a taskd, will run it. If provided a function, will use <a href="../modules/sched.html#new_task">new_task</a>
 to create a task first. This call yields control to the new task immediatelly.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">task</span>
         wither a <a href="../modules/sched.html#taskd">taskd</a> or function for the task.</li>
        <li><span class="parameter">...</span>
         parameters passed to the task upon first run.</li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        a task in the scheduler (see <a href="../modules/sched.html#taskd">taskd</a>).
    </ol>




</dd>
    <dt>
    <a name = "sigrun"></a>
    <strong>sigrun&nbsp;(waitd, f, attached)</strong>
    </dt>
    <dd>
    Create and run a task that listens for a signal.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">waitd</span>
         a Wait Descriptor for the signal (see <a href="../modules/sched.html#waitd">waitd</a>)</li>
        <li><span class="parameter">f</span>
         function to be called when the signal appears. The signal
 is passed to f as parameter.The signal will be provided as
 <em>event, parameters</em>, just as the result of a <a href="../modules/sched.html#wait">wait</a></li>
        <li><span class="parameter">attached</span>
         if true, the new task will run in attached mode</li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        task in the scheduler (see <a href="../modules/sched.html#taskd">taskd</a>).
    </ol>




</dd>
    <dt>
    <a name = "sigrunonce"></a>
    <strong>sigrunonce&nbsp;(waitd, f, attached)</strong>
    </dt>
    <dd>
    Create and run a task that listens for a signal, once.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">waitd</span>
         a Wait Descriptor for the signal (see <a href="../modules/sched.html#waitd">waitd</a>)</li>
        <li><span class="parameter">f</span>
         function to be called when the signal appears. The signal
 is passed to f as parameter. The signal will be provided as
 <em>event, parameters</em>, just as the result of a <a href="../modules/sched.html#wait">wait</a></li>
        <li><span class="parameter">attached</span>
         if true, the new task will run in attached more</li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        task in the scheduler (see <a href="../modules/sched.html#taskd">taskd</a>).
    </ol>




</dd>
    <dt>
    <a name = "set_pause"></a>
    <strong>set_pause&nbsp;(taskd, pause)</strong>
    </dt>
    <dd>
    Pause a task.
 A paused task won't be scheduled for execution. If paused while waiting for a signal,
 won't respond to signals. Signals on unbuffered waitds will get lost. Task's buffered
 waitds will still buffer events. Can be invoked as taskd:set_pause(pause)

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">taskd</span>
         Task to pause (see <a href="../modules/sched.html#taskd">taskd</a>).</li>
        <li><span class="parameter">pause</span>
         mode, true to pause, false to unpause</li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        the modified taskd on success or <em>nil, errormessage</em> on failure.
    </ol>




</dd>
    <dt>
    <a name = "kill"></a>
    <strong>kill&nbsp;(taskd)</strong>
    </dt>
    <dd>
    Finishes a task.
 The killed task will emit a signal <em>sched.EVENT_DIE, 'killed'</em>. Can be
 invoked as taskd:kill().

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">taskd</span>
         task to terminate (see <a href="../modules/sched.html#taskd">taskd</a>).</li>
    </ul>





</dd>
    <dt>
    <a name = "signal"></a>
    <strong>signal&nbsp;(event, ...)</strong>
    </dt>
    <dd>
    Emit a signal.
 Will give control immediatelly to tasks that are waiting on
 event, to regain it when they finish/block.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">event</span>
         event of the signal. Can be of any type.</li>
        <li><span class="parameter">...</span>
         further parameters to be sent with the signal.</li>
    </ul>





</dd>
    <dt>
    <a name = "schedule_signal"></a>
    <strong>schedule_signal&nbsp;(event, ...)</strong>
    </dt>
    <dd>
    Emit a signal lazily.
 Like <a href="../modules/sched.html#signal">signal</a>, except it does not yield control.
 Will schedule the event to be emitted after task yields by
 other means (it even can be delayed beyond that by the scheduler).
 Scheduled signals from multiple tasks will be
 emitted in order.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">event</span>
         event of the signal. Can be of any type.</li>
        <li><span class="parameter">...</span>
         further parameters to be sent with the signal.</li>
    </ul>





</dd>
    <dt>
    <a name = "step"></a>
    <strong>step&nbsp;()</strong>
    </dt>
    <dd>
    Runs a single step of the scheduler.


    <h3>Returns:</h3>
    <ol>

        the idle time available until more activity is expected; this
 means it will be 0 if there are active tasks.
    </ol>




</dd>
    <dt>
    <a name = "loop"></a>
    <strong>loop&nbsp;()</strong>
    </dt>
    <dd>
    Wait for the scheduler to finish.
 This call will block until there is no more task activity, i.e. there's no active task,
 and none of the waiting tasks has a timeout set.





    <h3>Usage:</h3>
    <ul>
        <pre class="example"> <span class="keyword">local</span> sched = <span class="global">require</span> <span class="string">'lumen.sched'</span>
 sched.run(<span class="keyword">function</span>()
    <span class="comment">--start at least one task
</span> <span class="keyword">end</span>)
 sched.loop()
 --potentially free any resources before finishing here  </pre>
    </ul>

</dd>
</dl>
    <h2><a name="Tables"></a>Tables</h2>
    <dl class="function">
    <dt>
    <a name = "EVENT_ANY"></a>
    <strong>EVENT_ANY</strong>
    </dt>
    <dd>
    Event used for all events
 When included in a <a href="../modules/sched.html#waitd">waitd</a>, will match any event.






</dd>
    <dt>
    <a name = "tasks"></a>
    <strong>tasks</strong>
    </dt>
    <dd>
    Tasks in scheduler.
 Table holding <a href="../modules/sched.html#taskd">taskd</a> objects of the tasks in the scheduler.





    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="keyword">for</span> taskd, _ <span class="keyword">in</span> <span class="global">pairs</span> (sched.tasks) <span class="keyword">do</span> <span class="global">print</span>(taskd) <span class="keyword">end</span></pre>
    </ul>

</dd>
</dl>
    <h2><a name="Fields"></a>Fields</h2>
    <dl class="function">
    <dt>
    <a name = "running_task"></a>
    <strong>running_task</strong>
    </dt>
    <dd>
    Currently running task.
 The task descriptor from current task.






</dd>
    <dt>
    <a name = "EVENT_DIE"></a>
    <strong>EVENT_DIE</strong>
    </dt>
    <dd>
    Task died event.
 This event will be emited when a task is either killed or finishes on error.
 The parameter is 'killed' if the task was killed, or the error message otherwise.





    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="comment">--prints each time a task dies
</span>sched.sigrun({sched.EVENT_DIE}, <span class="global">print</span>)</pre>
    </ul>

</dd>
    <dt>
    <a name = "EVENT_FINISH"></a>
    <strong>EVENT_FINISH</strong>
    </dt>
    <dd>
    Task finished event.
 This event will be emited when a task finishes normally.
 The parameters are the output of the task's function.





    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="comment">--prints each time a task finishes
</span>sched.sigrun({sched.EVENT_FINISH}, <span class="global">print</span>)</pre>
    </ul>

</dd>
    <dt>
    <a name = "to_clean_up"></a>
    <strong>to_clean_up</strong>
    </dt>
    <dd>
    Control memory collection.
 number of new insertions in waiting[event] before triggering clean_up.
 Defaults to 1000






</dd>
    <dt>
    <a name = "idle"></a>
    <strong>idle</strong>
    </dt>
    <dd>
    Idle function.
 Function called by the scheduler when there is
 nothing else to do (e.g., all tasks are waiting for a signal).
 This function should idle up to t time units. Replace with
 whatever your app uses. LuaSocket's sleep works just fine.
 It is allowed to idle for less than t; the empty function will
 result in a busy wait. Defaults to execution of Linux's "sleep" command
 or the Windows ping hack.

    <h3>:</h3>
    <ul>
        <li><span class="parameter">t</span>
         time to idle</li>
    </ul>





</dd>
</dl>
    <h2><a name="Data_structures"></a>Data structures </h2>
        Data structures.
 Main structures used.
    <dl class="function">
    <dt>
    <a name = "waitd"></a>
    <strong>waitd</strong>
    </dt>
    <dd>
    Wait descriptor.
 Specifies a condition on which wait. Includes a signal description,
 a optional timeout specification and buffer configuration.
 A wait descriptor can be reused (for example, when waiting inside a
 loop) and shared amongst different tasks. If a wait descriptor changes
 while there is a task waiting, the behavior is unspecified. Notice that
 when sharing a wait descriptor between several tasks, the buffer is
 associated to the wait descriptor, and tasks will service buffered signals
 on first request basis. <br/>
 Besides the following fields, provides methods for
 the sched functions that have a waitd as first parameter.

    <h3>Fields:</h3>
    <ul>
        <li><span class="parameter">array</span>
         The array part contains the events to wait. Can contain <a href="../modules/sched.html#EVENT_ANY">sched.EVENT_ANY</a> <br/>
 to mark interest in any event. If nil, will only return on timeout.</li>
        <li><span class="parameter">timeout</span>
         optional, time to wait. nil or negative waits for ever.</li>
        <li><span class="parameter">buff_mode</span>
         Specifies how to behave when inserting in a full buffer.
 'keep last' means replace with the new arrived signal. 'keep first'
 will skip the insertion in a full buffer. nil disables buffering</li>
    </ul>





</dd>
    <dt>
    <a name = "taskd"></a>
    <strong>taskd</strong>
    </dt>
    <dd>
    Task descriptor.
 Handler of a task. Besides the following fields, provides methods for
 the sched functions that have a taskd as first parameter.

    <h3>Fields:</h3>
    <ul>
        <li><span class="parameter">status</span>
         Status of the task, can be 'ready', 'paused' or 'dead'</li>
        <li><span class="parameter">waitingfor</span>
         If the the task is waiting for a signal, this is the
 Wait Descriptor (see <a href="../modules/sched.html#waitd">waitd</a>)</li>
        <li><span class="parameter">waketime</span>
         The time at which to task will be forced to wake-up (due
 to a timeout on a wait)</li>
        <li><span class="parameter">created_by</span>
         The task that started this one.</li>
        <li><span class="parameter">attached</span>
         Table containing attached tasks.</li>
        <li><span class="parameter">co</span>
         The coroutine of the task</li>
    </ul>





</dd>
</dl>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.3.12</a></i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
