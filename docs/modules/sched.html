<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Reference</title>
    <link rel="stylesheet" href="../ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>Lumen</h1>

<ul>
  <li><a href="../index.html">Index</a></li>
</ul>

<h2>Contents</h2>
<ul>
<li><a href="#Functions">Functions</a></li>
<li><a href="#Fields">Fields</a></li>
<li><a href="#Data_structures">Data structures</a></li>
</ul>


<h2>Modules</h2>
<ul>
  <li><a href="../modules/catalog.html">catalog</a></li>
  <li><a href="../modules/mutex.html">mutex</a></li>
  <li><a href="../modules/nixiorator.html">nixiorator</a></li>
  <li><a href="../modules/pipes.html">pipes</a></li>
  <li><strong>sched</strong></li>
  <li><a href="../modules/socketeer.html">socketeer</a></li>
</ul>
<h2>Topics</h2>
<ul>
  <li><a href="../topics/README.md.html">README.md</a></li>
</ul>
<h2>Examples</h2>
<ul>
  <li><a href="../examples/test-buff.lua.html">test-buff.lua</a></li>
  <li><a href="../examples/test-multiwait.lua.html">test-multiwait.lua</a></li>
  <li><a href="../examples/test-mutex.lua.html">test-mutex.lua</a></li>
  <li><a href="../examples/test-nixiorator.lua.html">test-nixiorator.lua</a></li>
  <li><a href="../examples/test-pipe.lua.html">test-pipe.lua</a></li>
  <li><a href="../examples/test-socketeer.lua.html">test-socketeer.lua</a></li>
  <li><a href="../examples/test-stress.lua.html">test-stress.lua</a></li>
  <li><a href="../examples/test.lua.html">test.lua</a></li>
</ul>

</div>

<div id="content">

<h1>Module <code>sched</code></h1>

<p>Lumen cooperative scheduler.</p>
<p> Lumen (Lua Multitasking Environment) is a simple environment 
 for coroutine based multitasking. Consists of a signal scheduler, 
 and that's it.
 Functions that receive a task or wait descriptors can be invoked as methods
 of the corresponing events. For example, sched.kill(task) can be invoked as 
 task:kill()</p>
    <h3>Usage:</h3>
    <ul>
        <pre class="example">local sched = require 'sched'</pre>
    </ul>

<h2><a href="#Functions">Functions</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#new_task">new_task&nbsp;(f)</a></td>
	<td class="summary">Create a task.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#new_sigrun_task">new_sigrun_task&nbsp;(waitd, f)</a></td>
	<td class="summary">Create a task that listens for a signal.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#new_sigrunonce_task">new_sigrunonce_task&nbsp;(waitd, f)</a></td>
	<td class="summary">Create a task that listens for a signal, once.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#run">run&nbsp;(task, ...)</a></td>
	<td class="summary">Run a task.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#attach">attach&nbsp;(taskd, taskd_child)</a></td>
	<td class="summary">Attach a task to another.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#set_as_attached">set_as_attached&nbsp;(taskd_child)</a></td>
	<td class="summary">Set a task as attached to the creator task.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#kill">kill&nbsp;(taskd)</a></td>
	<td class="summary">Finishes a task.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#signal">signal&nbsp;(event, ...)</a></td>
	<td class="summary">Emit a signal.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wait">wait&nbsp;(waitd)</a></td>
	<td class="summary">Wait for a signal.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#new_waitd">new_waitd&nbsp;(waitd_table)</a></td>
	<td class="summary">Create a Wait Descriptor.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#sleep">sleep&nbsp;(timeout)</a></td>
	<td class="summary">Sleeps the task for t time units.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#yield">yield&nbsp;()</a></td>
	<td class="summary">Yields the execution of a task, as in cooperative multitasking.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#set_pause">set_pause&nbsp;(taskd, pause)</a></td>
	<td class="summary">Pause a task.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#idle">idle&nbsp;(t)</a></td>
	<td class="summary">Idle function.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#get_time">get_time&nbsp;()</a></td>
	<td class="summary">Function used by the scheduler to get current time.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#step">step&nbsp;()</a></td>
	<td class="summary">Runs a single step of the scheduler.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#go">go&nbsp;()</a></td>
	<td class="summary">Starts the scheduler.</td>
	</tr>
</table>
<h2><a href="#Fields">Fields</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#EVENT_DIE">EVENT_DIE</a></td>
	<td class="summary">Task dying event.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#to_clean_up">to_clean_up</a></td>
	<td class="summary">Control memory collection.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#running_task">running_task</a></td>
	<td class="summary">Currently running task.</td>
	</tr>
</table>
<h2><a href="#Data_structures">Data structures</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#waitd">waitd</a></td>
	<td class="summary">Wait descriptor.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#taskd">taskd</a></td>
	<td class="summary">Task descriptor.</td>
	</tr>
</table>

<br/>
<br/>


    <h2><a name="Functions"></a>Functions</h2>
    
    <dl class="function">
    <dt>
    <a name = "new_task"></a>
    <strong>new_task&nbsp;(f)</strong>
    </dt>
    <dd>
    Create a task. 
 The task is created in paused mode. To run the created task,
 use <a href="../modules/sched.html#run">run</a> or <a href="../modules/sched.html#set_pause">set_pause</a>
 The task will emit a sched.EVENT_DIE, true, params...
 signal upon normal finalization, were params are the returns of f.
 If there is a error, the task will emit a sched.EVENT_DIE, false, err were
 err is the error message.

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>f</em></code>:  function for the task</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        task in the scheduler (see <a href="../modules/sched.html#taskd">taskd</a>).
    </ol>


</dd>
    <dt>
    <a name = "new_sigrun_task"></a>
    <strong>new_sigrun_task&nbsp;(waitd, f)</strong>
    </dt>
    <dd>
    Create a task that listens for a signal. 

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>waitd</em></code>:  a Wait Descriptor for the signal (see <a href="../modules/sched.html#waitd">waitd</a>)</li>
       <li><code><em>f</em></code>:  function to be called when the signal appears. The signal
 is passed to f as parameter.The signal will be provided as 
 emitter, event, event_parameters, just as the result of a <a href="../modules/sched.html#wait">wait</a></li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        task in the scheduler (see <a href="../modules/sched.html#taskd">taskd</a>).
    </ol>


    <h3>see also:</h3>
    <ul>
         <li><a href="../modules/sched.html#wait">wait</a></li>
         <li><a href="../modules/sched.html#run">run</a></li>
    </ul>
</dd>
    <dt>
    <a name = "new_sigrunonce_task"></a>
    <strong>new_sigrunonce_task&nbsp;(waitd, f)</strong>
    </dt>
    <dd>
    Create a task that listens for a signal, once. 

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>waitd</em></code>:  a Wait Descriptor for the signal (see <a href="../modules/sched.html#waitd">waitd</a>)</li>
       <li><code><em>f</em></code>:  function to be called when the signal appears. The signal
 is passed to f as parameter. The signal will be provided as 
 emitter, event, event_parameters, just as the result of a <a href="../modules/sched.html#wait">wait</a></li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        task in the scheduler (see <a href="../modules/sched.html#taskd">taskd</a>).
    </ol>


    <h3>see also:</h3>
    <ul>
         <li><a href="../modules/sched.html#wait">wait</a></li>
         <li><a href="../modules/sched.html#run">run</a></li>
    </ul>
</dd>
    <dt>
    <a name = "run"></a>
    <strong>run&nbsp;(task, ...)</strong>
    </dt>
    <dd>
    Run a task. 
 Can be provided either a <a href="../modules/sched.html#taskd">taskd</a> or a function with optional parameters.
 If provided a taskd, will run it. If provided a function, will use <a href="../modules/sched.html#new_task">new_task</a>
 to create a task first.

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>task</em></code>:  wither a <a href="../modules/sched.html#taskd">taskd</a> or function for the task.</li>
       <li><code><em>...</em></code>:  parameters passed to the task upon first run.</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        a task in the scheduler (see <a href="../modules/sched.html#taskd">taskd</a>).
    </ol>


</dd>
    <dt>
    <a name = "attach"></a>
    <strong>attach&nbsp;(taskd, taskd_child)</strong>
    </dt>
    <dd>
    Attach a task to another. 
 An attached task will be killed by the scheduler whenever
 the parent task is finished (returns, errors or is killed)

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>taskd</em></code>:  The parent task</li>
       <li><code><em>taskd_child</em></code>:  The child (attached) task.</li>
    </ul>




</dd>
    <dt>
    <a name = "set_as_attached"></a>
    <strong>set_as_attached&nbsp;(taskd_child)</strong>
    </dt>
    <dd>
    Set a task as attached to the creator task. 
 An attached task will be killed by the scheduler whenever
 the parent task (the task that created it) is finished (returns, errors or is killed)

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>taskd_child</em></code>:  The child (attached) task.</li>
    </ul>




</dd>
    <dt>
    <a name = "kill"></a>
    <strong>kill&nbsp;(taskd)</strong>
    </dt>
    <dd>
    Finishes a task. 
 The killed task will emit a signal sched.EVENT_DIE, false, 'killed'. Can be 
 invoked as taskd:kill().

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>taskd</em></code>:  task to terminate (see <a href="../modules/sched.html#taskd">taskd</a>).</li>
    </ul>




</dd>
    <dt>
    <a name = "signal"></a>
    <strong>signal&nbsp;(event, ...)</strong>
    </dt>
    <dd>
    Emit a signal. 

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>event</em></code>:  event of the signal. Can be of any type.</li>
       <li><code><em>...</em></code>:  further parameters to be sent with the signal.</li>
    </ul>




</dd>
    <dt>
    <a name = "wait"></a>
    <strong>wait&nbsp;(waitd)</strong>
    </dt>
    <dd>
    Wait for a signal. 
 Pauses the task until (one of) the specified signal(s) is available.
 If there are signals in the buffer, will return the first immediately.
 Otherwise will block the task until signal arrival, or a timeout.
 If provided a table as parameter, will use <a href="../modules/sched.html#new_waitd">new_waitd</a> to convert it
 to a wait desciptor.

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>waitd</em></code>:  a Wait Descriptor for the signal (see <a href="../modules/sched.html#waitd">waitd</a>)</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        On event returns emitter, event, event_parameters. On timeout
 returns nil, 'timeout'
    </ol>


</dd>
    <dt>
    <a name = "new_waitd"></a>
    <strong>new_waitd&nbsp;(waitd_table)</strong>
    </dt>
    <dd>
    Create a Wait Descriptor. 
 Creates <a href="../modules/sched.html#waitd">waitd</a> object in the scheduler. Notice that buffering waitds
 start buffering as soon they are created.

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>waitd_table</em></code>:  a table to convert into a wait descriptor.</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        a wait descriptor object.
    </ol>


</dd>
    <dt>
    <a name = "sleep"></a>
    <strong>sleep&nbsp;(timeout)</strong>
    </dt>
    <dd>
    Sleeps the task for t time units. 
 Time computed according to @{get_time}.

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>timeout</em></code>:  time to sleep</li>
    </ul>




</dd>
    <dt>
    <a name = "yield"></a>
    <strong>yield&nbsp;()</strong>
    </dt>
    <dd>
    Yields the execution of a task, as in cooperative multitasking. 





</dd>
    <dt>
    <a name = "set_pause"></a>
    <strong>set_pause&nbsp;(taskd, pause)</strong>
    </dt>
    <dd>
    Pause a task. 
 A paused task won't be scheduled for execution. If paused while waiting for a signal, 
 won't respond to signals. Signals on unbuffered waitds will get lost. Task's buffered 
 waitds will still buffer events. Can be invoked as taskd:set_pause(pause)

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>taskd</em></code>:  Task to pause (see <a href="../modules/sched.html#taskd">taskd</a>).</li>
       <li><code><em>pause</em></code>:  mode, true to pause, false to unpause</li>
    </ul>


    <h3>Returns:</h3>
    <ol>
        true on success or nil, errormessage on failure
    </ol>


</dd>
    <dt>
    <a name = "idle"></a>
    <strong>idle&nbsp;(t)</strong>
    </dt>
    <dd>
    Idle function. 
 Function called by the scheduler when there is
 nothing else to do (e.g., all tasks are waiting for a signal).
 This function should idle up to t time units. Replace with
 whatever your app uses. LuaSocket's sleep works just fine.
 It is allowed to idle for less than t; the empty function will
 result in a busy wait. Defaults to execution of Linux's "sleep" command.

    <h3>Parameters:</h3>
    <ul>
       <li><code><em>t</em></code>:  time to idle</li>
    </ul>




</dd>
    <dt>
    <a name = "get_time"></a>
    <strong>get_time&nbsp;()</strong>
    </dt>
    <dd>
    Function used by the scheduler to get current time. 
 Replace with whatever your app uses. LuaSocket's gettime works just fine.
 Defaults to os.time.





</dd>
    <dt>
    <a name = "step"></a>
    <strong>step&nbsp;()</strong>
    </dt>
    <dd>
    Runs a single step of the scheduler. 



    <h3>Returns:</h3>
    <ol>
        the idle time available until more activity is expected; this
 means it will be 0 if there are active tasks.
    </ol>


</dd>
    <dt>
    <a name = "go"></a>
    <strong>go&nbsp;()</strong>
    </dt>
    <dd>
    Starts the scheduler. 
 Will run until there is no more activity, i.e. there's no active task,
 and none of the waiting tasks has a timeout set.





</dd>
</dl>
    <h2><a name="Fields"></a>Fields</h2>
    
    <dl class="function">
    <dt>
    <a name = "EVENT_DIE"></a>
    <strong>EVENT_DIE</strong>
    </dt>
    <dd>
    Task dying event. 
 This event will be emitted when a task dies. When the task dies a natural 
 death (finishes), the first parameter is true, followed by 
 the task returns. Otherwise, the first parameter is nil and the second 
 is 'killed' if the task was killed, or the error message if the task errore'd.


    <h3>Usage:</h3>
    <ul>
        <pre class="example">--prints each time a task dies
sched.sigrun({emitter='*', events={sched.EVENT_DIE}}, print)</pre>
    </ul>



</dd>
    <dt>
    <a name = "to_clean_up"></a>
    <strong>to_clean_up</strong>
    </dt>
    <dd>
    Control memory collection. 
 number of new insertions in waiting[event] before triggering clean_up.
 Defaults to 1000





</dd>
    <dt>
    <a name = "running_task"></a>
    <strong>running_task</strong>
    </dt>
    <dd>
    Currently running task. 
 the task descriptor from current task.





</dd>
</dl>
    <h2><a name="Data_structures"></a>Data structures</h2>
     Main structures used.
    <dl class="function">
    <dt>
    <a name = "waitd"></a>
    <strong>waitd</strong>
    </dt>
    <dd>
    Wait descriptor. 
 Specifies a condition on which wait. Includes a signal description,
 a optional timeout specification and buffer configuration.
 A wait descriptor can be reused (for example, when waiting inside a
 loop) and shared amongst different tasks. If a wait descriptor changes
 while there is a task waiting, the behavior is unspecified. Notice that
 when sharing a wait descriptor between several tasks, the buffer is
 associated to the wait descriptor, and tasks will service buffered signals
 on first request basis.

    <h3>Fields:</h3>
    <ul>
       <li><code><em>emitter</em></code>:  optional, task originating the signal we wait for. If nil, will
 only return on timeout. If '*', means anyone. I also can be an array of 
 tasks, in which case any of them is accepted as a source (see <a href="../modules/sched.html#taskd">taskd</a>).</li>
       <li><code><em>timeout</em></code>:  optional, time to wait. nil or negative waits for ever.</li>
       <li><code><em>buff_len</em></code>:  Maximum length of the buffer. A buffer allows for storing
 signals that arrived while the task is not blocked on the wait descriptor.
 Whenever there is an attempt to insert in a full buffer, the dropped
 flag is set. nil o 0 disables, negative means no length limit.</li>
       <li><code><em>buff_mode</em></code>:  Specifies how to behave when inserting in a full buffer.
 'drop first' means drop the oldest signals to make space. 'drop last'
 or nil will skip the insertion in a full buffer.</li>
       <li><code><em>dropped</em></code>:  the scheduler will set this to true when dropping events
 from the buffer. Can be reset by the user.</li>
       <li><code><em>events</em></code>:  optional, array with the events to wait. Can contain a '*', 
 or be '*' instead of a table, to mark interest in any event</li>
    </ul>




</dd>
    <dt>
    <a name = "taskd"></a>
    <strong>taskd</strong>
    </dt>
    <dd>
    Task descriptor. 
 Handler of a task. Besides the following fields, provides methods for
 the sched functions that have a taskd as first parameter.

    <h3>Fields:</h3>
    <ul>
       <li><code><em>status</em></code>:  Status of the task, can be 'ready', 'paused' or 'dead'</li>
       <li><code><em>waitingfor</em></code>:  If the the task is waiting for a signal, this is the 
 Wait Descriptor (see <a href="../modules/sched.html#waitd">waitd</a>)</li>
       <li><code><em>waketime</em></code>:  The time at which to task will be forced to wake-up (due
 to a timeout on a wait)</li>
       <li><code><em>created_by</em></code>:  The task that started this one.</li>
       <li><code><em>attached</em></code>:  Table containing attached tasks.</li>
       <li><code><em>co</em></code>:  The coroutine of the task</li>
    </ul>




</dd>
</dl>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.1</a></i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
